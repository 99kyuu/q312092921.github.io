{"title":"day08笔记","slug":"day08笔记","date":"2016-12-21T10:59:08.123Z","updated":"2016-12-21T10:20:55.333Z","comments":true,"path":"api/articles/day08笔记.json","excerpt":"","raw":"---\ntitle: day08笔记\n---\n###08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)\n* A:代码块概述\n\t* 在Java中，使用{}括起来的代码被称为代码块。\n* B:代码块分类\n\t* 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。\n* C:常见代码块的应用\n\t* a:局部代码块 \n\t\t* 在方法中出现；限定变量生命周期，及早释放，提高内存利用率\n\t* b:构造代码块 (初始化块)\n\t\t* 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行\n\t* c:静态代码块 \n\t\t* 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。\n\t\t* 一般用于加载驱动\n\n###08.02_面向对象(代码块的面试题)(掌握)\n* A:看程序写结果\n* \n\t\tclass Student {\n\t\t\tstatic {\n\t\t\t\tSystem.out.println(\"Student 静态代码块\");\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tSystem.out.println(\"Student 构造代码块\");\n\t\t\t}\n\t\t\t\n\t\t\tpublic Student() {\n\t\t\t\tSystem.out.println(\"Student 构造方法\");\n\t\t\t}\n\t\t}\n\t\n\t\tclass Demo2_Student {\n\t\t\tstatic {\n\t\t\t\tSystem.out.println(\"Demo2_Student静态代码块\");\n\t\t\t}\n\t\t\t\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tSystem.out.println(\"我是main方法\");\n\t\t\t\t\n\t\t\t\tStudent s1 = new Student();\n\t\t\t\tStudent s2 = new Student();\n\t\t\t}\n\t\t}\n\n\n###08.03_面向对象(继承案例演示)(掌握)\n* A:继承(extends)\n\t* 让类与类之间产生关系,子父类关系 \n* B:继承案例演示：\n\t* 动物类,猫类,狗类\n\t* 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)\n* C:案例演示\n\t* 使用继承前\n* D:案例演示\n\t* 使用继承后\n\n###08.04_面向对象(继承的好处和弊端)(掌握)\n* A:继承的好处\n\t* a:提高了代码的复用性\n\t* b:提高了代码的维护性\n\t* c:让类与类之间产生了关系，是多态的前提\n* B:继承的弊端\n\t* 类的耦合性增强了。\n\t\n\t* 开发的原则：高内聚，低耦合。\n\t* 耦合：类与类的关系\n\t* 内聚：就是自己完成某件事情的能力\n\n###08.05_面向对象(Java中类的继承特点)(掌握)\n* A:Java中类的继承特点\n\t* a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)\n\t\t* 有些语言是支持多继承，格式：extends 类1,类2,...\n\t* b:Java支持多层继承(继承体系)\n* B:案例演示\n\t* Java中类的继承特点\n\t\t* 如果想用这个体系的所有功能用最底层的类创建对象\n\t\t* 如果想看这个体系的共性功能,看最顶层的类 \n\n###08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)\n* A:继承的注意事项\n\t* a:子类只能继承父类所有非私有的成员(成员方法和成员变量)\n\t* b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。\n\t* c:不要为了部分功能而去继承\n\t* 项目经理 姓名 工号 工资 奖金\n\t* 程序员\t姓名 工号 工资\n* B:什么时候使用继承\n\t* 继承其实体现的是一种关系：\"is a\"。\n\t\tPerson\n\t\t\tStudent\n\t\t\tTeacher\n\t\t水果\n\t\t\t苹果\n\t\t\t香蕉\n\t\t\t橘子\n\t\t\t\n\t采用假设法。\n\t\t如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。\n\n###08.07_面向对象(继承中成员变量的关系)(掌握)\n* A:案例演示\n\t* a:不同名的变量\n\t* b:同名的变量\n###08.08_面向对象(this和super的区别和应用)(掌握)\n* A:this和super都代表什么\n\t* this:代表当前对象的引用,谁来调用我,我就代表谁\n\t* super:代表当前对象父类的引用\n* B:this和super的使用区别\n\t* a:调用成员变量\n\t\t* this.成员变量 调用本类的成员变量,也可以调用父类的成员变量\n\t\t* super.成员变量 调用父类的成员变量\n\t* b:调用构造方法\n\t\t* this(...)\t调用本类的构造方法\n\t\t* super(...)\t调用父类的构造方法\n\t* c:调用成员方法\n\t\t* this.成员方法 调用本类的成员方法,也可以调用父类的方法\n\t\t* super.成员方法 调用父类的成员方法\n\t\t\n\n###08.09_面向对象(继承中构造方法的关系)(掌握)\n* A:案例演示\n\t* 子类中所有的构造方法默认都会访问父类中空参数的构造方法\n* B:为什么呢?\n\t* 因为子类会继承父类中的数据，可能还会使用父类的数据。\n\t* 所以，子类初始化之前，一定要先完成父类数据的初始化。\n\t\n\t* 其实：\n\t\t* 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。\n\n###08.10_面向对象(继承中构造方法的注意事项)(掌握)\n* A:案例演示\n\t* 父类没有无参构造方法,子类怎么办?\n\t* super解决\n\t* this解决\n* B:注意事项\n\t* super(…)或者this(….)必须出现在构造方法的第一条语句上\n\n###08.11_面向对象(继承中的面试题)(掌握)\n\n* A:案例演示\n* \t\t\n\t\t看程序写结果1\n\t\tclass Fu{\n\t\t\tpublic int num = 10;\n\t\t\tpublic Fu(){\n\t\t\t\tSystem.out.println(\"fu\");\n\t\t\t}\n\t\t}\n\t\tclass Zi extends Fu{\n\t\t\tpublic int num = 20;\n\t\t\tpublic Zi(){\n\t\t\t\tSystem.out.println(\"zi\");\n\t\t\t}\n\t\t\tpublic void show(){\n\t\t\t\tint num = 30;\n\t\t\t\tSystem.out.println(num);\n\t\t\t\tSystem.out.println(this.num);\n\t\t\t\tSystem.out.println(super.num);\n\t\t\t}\n\t\t}\n\t\tclass Test1_Extends {\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tZi z = new Zi();\n\t\t\t\tz.show();\n\t\t\t}\n\t\t}\n\n\t\t看程序写结果2\n\t\tclass Fu {\n\t\t\tstatic {\n\t\t\t\tSystem.out.println(\"静态代码块Fu\");\n\t\t\t}\n\t\n\t\t\t{\n\t\t\t\tSystem.out.println(\"构造代码块Fu\");\n\t\t\t}\n\t\n\t\t\tpublic Fu() {\n\t\t\t\tSystem.out.println(\"构造方法Fu\");\n\t\t\t}\n\t\t}\n\t\n\t\tclass Zi extends Fu {\n\t\t\tstatic {\n\t\t\t\tSystem.out.println(\"静态代码块Zi\");\n\t\t\t}\n\t\n\t\t\t{\n\t\t\t\tSystem.out.println(\"构造代码块Zi\");\n\t\t\t}\n\t\n\t\t\tpublic Zi() {\n\t\t\t\tSystem.out.println(\"构造方法Zi\");\n\t\t\t}\n\t\t}\n\t\n\t\tZi z = new Zi(); 请执行结果。\n\n###08.12_面向对象(继承中成员方法关系)(掌握)\n* A:案例演示\n\t* a:不同名的方法\n\t* b:同名的方法\n\n###08.13_面向对象(方法重写概述及其应用)(掌握)\n* A:什么是方法重写\n\t* 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) \n* B:方法重写的应用：\n\t* 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。\n* C:案例演示\n\t* a:定义一个手机类。\n\n###08.14_面向对象(方法重写的注意事项)(掌握)\n* A:方法重写注意事项\n\t* a:父类中私有方法不能被重写\n\t\t* 因为父类私有方法子类根本就无法继承\n\t* b:子类重写父类方法时，访问权限不能更低\n\t\t* 最好就一致\n\t* c:父类静态方法，子类也必须通过静态方法进行重写\n\t\t* 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)\n\t\t\n\t* 子类重写父类方法的时候，最好声明一模一样。\n* B:案例演示\n\t* 方法重写注意事项\n\n###08.15_面向对象(方法重写的面试题)(掌握)\n* A:方法重写的面试题\n\t* Override和Overload的区别?Overload能改变返回值类型吗?\n\t* overload可以改变返回值类型,只看参数列表\n\t* 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的\n\t\n\t* 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。\n\n\t* 子类对象调用方法的时候：\n\t\t* 先找子类本身，再找父类。\n\n###08.16_面向对象(使用继承前的学生和老师案例)(掌握)\n* A:案例演示\n\t* 使用继承前的学生和老师案例\n\t* 属性:姓名,年龄\n\t* 行为:吃饭\n\t* 老师有特有的方法:讲课\n\t* 学生有特有的方法:学习\n\n###08.17_面向对象(使用继承后的学生和老师案例)(掌握)\n* A:案例演示\n\t* 使用继承后的学生和老师案例\n\n###08.18_面向对象(猫狗案例分析,实现及测试)(掌握)\n* A:猫狗案例分析\n* B:案例演示\n\t* 猫狗案例继承版\n\t* 属性:毛的颜色,腿的个数\n\t* 行为:吃饭\n\t* 猫特有行为:抓老鼠catchMouse\n\t* 狗特有行为:看家lookHome\n\n\n###08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)\n* A:final概述\n* B:final修饰特点\n\t* 修饰类，类不能被继承\n\t* 修饰变量，变量就变成了常量，只能被赋值一次\n\t* 修饰方法，方法不能被重写\n* C:案例演示\n\t* final修饰特点\n\n###08.20_面向对象(final关键字修饰局部变量)(掌握)\n* A:案例演示\n\t* 方法内部或者方法声明上都演示一下(了解)\n\n\t* 基本类型，是值不能被改变\n\t* 引用类型，是地址值不能被改变,对象中的属性可以改变\n\n###08.21_面向对象(final修饰变量的初始化时机)(掌握)\n* A:final修饰变量的初始化时机\n\t* 显示初始化 \n\t* 在对象构造完毕前即可\n\t\n###08.22_day08总结\n* 把今天的知识点总结一遍。","categories":[],"tags":[]}