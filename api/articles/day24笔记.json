{"title":"day24笔记","slug":"day24笔记","date":"2016-12-21T10:59:15.880Z","updated":"2016-12-21T10:23:31.297Z","comments":true,"path":"api/articles/day24笔记.json","excerpt":"","raw":"---\ntitle: day24笔记\n---\n###24.01_多线程(多线程的引入)(了解)\n* 1.什么是线程\n\t* 线程是程序执行的一条路径, 一个进程中可以包含多条线程\n\t* 多线程并发执行可以提高程序的效率, 可以同时完成多项工作\n* 2.多线程的应用场景\n\t* 红蜘蛛同时共享屏幕给多个电脑\n\t* 迅雷开启多条线程一起下载\n\t* QQ同时和多个人一起视频\n\t* 服务器同时处理多个客户端请求\n\t\n###24.02_多线程(多线程并行和并发的区别)(了解)\n* 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)\n* 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。\n* 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。\n* 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。\n\n###24.03_多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)\n* A:Java程序运行原理\n\t* Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。\n\t\n* B:JVM的启动是多线程的吗\n\t* JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。\n\n###24.04_多线程(多线程程序实现的方式1)(掌握)\n* 1.继承Thread\n\t* 定义类继承Thread\n\t* 重写run方法\n\t* 把新线程要做的事写在run方法中\n\t* 创建线程对象\n\t* 开启新线程, 内部会自动执行run方法\n\t* \n\t\t\n\t\t\tpublic class Demo2_Thread {\n\t\t\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) {\n\t\t\t\t\tMyThread mt = new MyThread();\t\t\t\t\t\t\t//4,创建自定义类的对象\n\t\t\t\t\tmt.start();\t\t\t\t\t\t\t\t\t\t\t\t//5,开启线程\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < 3000; i++) {\n\t\t\t\t\t\tSystem.out.println(\"bb\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tclass MyThread extends Thread {\t\t\t\t\t\t\t\t\t//1,定义类继承Thread\n\t\t\t\tpublic void run() {\t\t\t\t\t\t\t\t\t\t\t//2,重写run方法\n\t\t\t\t\tfor(int i = 0; i < 3000; i++) {\t\t\t\t\t\t\t//3,将要执行的代码,写在run方法中\n\t\t\t\t\t\tSystem.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n###24.05_多线程(多线程程序实现的方式2)(掌握)\n* 2.实现Runnable\n\t* 定义类实现Runnable接口\n\t* 实现run方法\n\t* 把新线程要做的事写在run方法中\n\t* 创建自定义的Runnable的子类对象\n\t* 创建Thread对象, 传入Runnable\n\t* 调用start()开启新线程, 内部会自动调用Runnable的run()方法\n\n\t\t\tpublic class Demo3_Runnable {\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) {\n\t\t\t\t\tMyRunnable mr = new MyRunnable();\t\t\t\t\t\t//4,创建自定义类对象\n\t\t\t\t\t//Runnable target = new MyRunnable();\n\t\t\t\t\tThread t = new Thread(mr);\t\t\t\t\t\t\t\t//5,将其当作参数传递给Thread的构造函数\n\t\t\t\t\tt.start();\t\t\t\t\t\t\t\t\t\t\t\t//6,开启线程\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < 3000; i++) {\n\t\t\t\t\t\tSystem.out.println(\"bb\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tclass MyRunnable implements Runnable {\t\t\t\t\t\t\t//1,自定义类实现Runnable接口\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\t\t\t\t\t\t\t\t\t\t\t//2,重写run方法\n\t\t\t\t\tfor(int i = 0; i < 3000; i++) {\t\t\t\t\t\t\t//3,将要执行的代码,写在run方法中\n\t\t\t\t\t\tSystem.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n###24.06_多线程(实现Runnable的原理)(了解)\n* 查看源码\n\t* 1,看Thread类的构造函数,传递了Runnable接口的引用 \n\t* 2,通过init()方法找到传递的target给成员变量的target赋值\n\t* 3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法\n\n###24.07_多线程(两种方式的区别)(掌握)\n* 查看源码的区别:\n\t* a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法\n\t* b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法\n\t\n* 继承Thread\n\t* 好处是:可以直接使用Thread类中的方法,代码简单\n\t* 弊端是:如果已经有了父类,就不能用这种方法\n* 实现Runnable接口\n\t* 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的\n\t* 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂\n###24.08_多线程(匿名内部类实现线程的两种方式)(掌握)\n* 继承Thread类\n\t \t\n\t\tnew Thread() {\t\t\t\t\t\t\t\t\t\t\t\t\t//1,new 类(){}继承这个类\n\t\t\tpublic void run() {\t\t\t\t\t\t\t\t\t\t\t//2,重写run方法\n\t\t\t\tfor(int i = 0; i < 3000; i++) {\t\t\t\t\t\t\t//3,将要执行的代码,写在run方法中\n\t\t\t\t\tSystem.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n* 实现Runnable接口\n\t\t\t\n\t\tnew Thread(new Runnable(){\t\t\t\t\t\t\t\t\t\t//1,new 接口(){}实现这个接口\n\t\t\tpublic void run() {\t\t\t\t\t\t\t\t\t\t\t//2,重写run方法\n\t\t\t\tfor(int i = 0; i < 3000; i++) {\t\t\t\t\t\t\t//3,将要执行的代码,写在run方法中\n\t\t\t\t\tSystem.out.println(\"bb\");\n\t\t\t\t}\n\t\t\t}\n\t\t}).start(); \n\n###24.09_多线程(获取名字和设置名字)(掌握)\n* 1.获取名字\n\t* 通过getName()方法获取线程对象的名字\n* 2.设置名字\n\t* 通过构造函数可以传入String类型的名字\n\t* \n\t\t\tnew Thread(\"xxx\") {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t\t\n\t\t\tnew Thread(\"yyy\") {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(this.getName() + \"....bb\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start(); \n\t* 通过setName(String)方法可以设置线程对象的名字\n\t* \n\t\t\tThread t1 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tThread t2 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(this.getName() + \"....bb\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tt1.setName(\"芙蓉姐姐\");\n\t\t\tt2.setName(\"凤姐\");\n\t\t\t\n\t\t\tt1.start();\n\t\t\tt2.start();\n\n###24.10_多线程(获取当前线程的对象)(掌握)\n* Thread.currentThread(), 主线程也可以获取\n\t* \n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"...aaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t\t\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"...bb\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t\tThread.currentThread().setName(\"我是主线程\");\t\t\t\t\t//获取主函数线程的引用,并改名字\n\t\t\tSystem.out.println(Thread.currentThread().getName());\t\t//获取主函数线程的引用,并获取名字\n###24.11_多线程(休眠线程)(掌握)\n* Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 * 1000 * 1000纳秒 1000000000\n\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 10; i++) {\n\t\t\t\t\t\tSystem.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t\t\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 10; i++) {\n\t\t\t\t\t\tSystem.out.println(getName() + \"...bb\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n###24.12_多线程(守护线程)(掌握)\n* setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出\n\t* \n\t\t\tThread t1 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 50; i++) {\n\t\t\t\t\t\tSystem.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tThread t2 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\t\t\tSystem.out.println(getName() + \"...bb\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tt1.setDaemon(true);\t\t\t\t\t\t//将t1设置为守护线程\n\t\t\t\n\t\t\tt1.start();\n\t\t\tt2.start();\n###24.13_多线程(加入线程)(掌握)\n* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续\n* join(int), 可以等待指定的毫秒之后继续\n\t* \n\t\t\tfinal Thread t1 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 50; i++) {\n\t\t\t\t\t\tSystem.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tThread t2 = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor(int i = 0; i < 50; i++) {\n\t\t\t\t\t\tif(i == 2) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t//t1.join();\t\t\t\t\t\t//插队,加入\n\t\t\t\t\t\t\t\tt1.join(30);\t\t\t\t\t\t//加入,有固定的时间,过了固定时间,继续交替执行\n\t\t\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.out.println(getName() + \"...bb\");\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tt1.start();\n\t\t\tt2.start();\n###24.14_多线程(礼让线程)(了解)\n* yield让出cpu\n\n###24.15_多线程(设置线程的优先级)(了解)\n* setPriority()设置线程的优先级\n\n###24.16_多线程(同步代码块)(掌握)\n* 1.什么情况下需要同步\n\t* 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.\n\t* 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.\n* 2.同步代码块\n\t* 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块\n\t* 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的\n\n\t\t\tclass Printer {\n\t\t\t\tDemo d = new Demo();\n\t\t\t\tpublic static void print1() {\n\t\t\t\t\tsynchronized(d){\t\t\t\t//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象\n\t\t\t\t\t\tSystem.out.print(\"黑\");\n\t\t\t\t\t\tSystem.out.print(\"马\");\n\t\t\t\t\t\tSystem.out.print(\"程\");\n\t\t\t\t\t\tSystem.out.print(\"序\");\n\t\t\t\t\t\tSystem.out.print(\"员\");\n\t\t\t\t\t\tSystem.out.print(\"\\r\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tpublic static void print2() {\t\n\t\t\t\t\tsynchronized(d){\t\n\t\t\t\t\t\tSystem.out.print(\"传\");\n\t\t\t\t\t\tSystem.out.print(\"智\");\n\t\t\t\t\t\tSystem.out.print(\"播\");\n\t\t\t\t\t\tSystem.out.print(\"客\");\n\t\t\t\t\t\tSystem.out.print(\"\\r\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n###24.17_多线程(同步方法)(掌握)\n* 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的\n\n\t\tclass Printer {\n\t\t\tpublic static void print1() {\n\t\t\t\tsynchronized(Printer.class){\t\t\t\t//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象\n\t\t\t\t\tSystem.out.print(\"黑\");\n\t\t\t\t\tSystem.out.print(\"马\");\n\t\t\t\t\tSystem.out.print(\"程\");\n\t\t\t\t\tSystem.out.print(\"序\");\n\t\t\t\t\tSystem.out.print(\"员\");\n\t\t\t\t\tSystem.out.print(\"\\r\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * 非静态同步函数的锁是:this\n\t\t\t * 静态的同步函数的锁是:字节码对象\n\t\t\t */\n\t\t\tpublic static synchronized void print2() {\t\n\t\t\t\tSystem.out.print(\"传\");\n\t\t\t\tSystem.out.print(\"智\");\n\t\t\t\tSystem.out.print(\"播\");\n\t\t\t\tSystem.out.print(\"客\");\n\t\t\t\tSystem.out.print(\"\\r\\n\");\n\t\t\t}\n\t\t}\n\n###24.18_多线程(线程安全问题)(掌握)\n* 多线程并发操作同一数据时, 就有可能出现线程安全问题\n* 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作\n\t\t\t\n\t\t\tpublic class Demo2_Synchronized {\n\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t * 需求:铁路售票,一共100张,通过四个窗口卖完.\n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) {\n\t\t\t\t\tTicketsSeller t1 = new TicketsSeller();\n\t\t\t\t\tTicketsSeller t2 = new TicketsSeller();\n\t\t\t\t\tTicketsSeller t3 = new TicketsSeller();\n\t\t\t\t\tTicketsSeller t4 = new TicketsSeller();\n\t\t\t\t\t\n\t\t\t\t\tt1.setName(\"窗口1\");\n\t\t\t\t\tt2.setName(\"窗口2\");\n\t\t\t\t\tt3.setName(\"窗口3\");\n\t\t\t\t\tt4.setName(\"窗口4\");\n\t\t\t\t\tt1.start();\n\t\t\t\t\tt2.start();\n\t\t\t\t\tt3.start();\n\t\t\t\t\tt4.start();\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tclass TicketsSeller extends Thread {\n\t\t\t\tprivate static int tickets = 100;\n\t\t\t\tstatic Object obj = new Object();\n\t\t\t\tpublic TicketsSeller() {\n\t\t\t\t\tsuper();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tpublic TicketsSeller(String name) {\n\t\t\t\t\tsuper(name);\n\t\t\t\t}\n\t\t\t\tpublic void run() {\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tsynchronized(obj) {\n\t\t\t\t\t\t\tif(tickets <= 0) \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tThread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(getName() + \"...这是第\" + tickets-- + \"号票\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n###24.19_多线程(火车站卖票的例子用实现Runnable接口)(掌握)\n\n\n###24.20_多线程(死锁)(了解)\n* 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁\n\t* 尽量不要嵌套使用\n\t\t\n\t\t\tprivate static String s1 = \"筷子左\";\n\t\t\tprivate static String s2 = \"筷子右\";\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tsynchronized(s1) {\n\t\t\t\t\t\t\t\tSystem.out.println(getName() + \"...拿到\" + s1 + \"等待\" + s2);\n\t\t\t\t\t\t\t\tsynchronized(s2) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(getName() + \"...拿到\" + s2 + \"开吃\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t\t\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tsynchronized(s2) {\n\t\t\t\t\t\t\t\tSystem.out.println(getName() + \"...拿到\" + s2 + \"等待\" + s1);\n\t\t\t\t\t\t\t\tsynchronized(s1) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(getName() + \"...拿到\" + s1 + \"开吃\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t}\n\n###24.21_多线程(以前的线程安全的类回顾)(掌握)\n* A:回顾以前说过的线程安全问题\n\t* 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)\n\t* Vector是线程安全的,ArrayList是线程不安全的\n\t* StringBuffer是线程安全的,StringBuilder是线程不安全的\n\t* Hashtable是线程安全的,HashMap是线程不安全的\n###24.22_多线程(总结)\t\n","categories":[],"tags":[]}