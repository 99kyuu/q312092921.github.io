{"title":"Day27笔记","slug":"day27笔记","date":"2016-12-21T16:30:55.000Z","updated":"2016-12-21T16:50:55.000Z","comments":true,"path":"api/articles/day27笔记.json","excerpt":"","raw":"---\ntitle: day27笔记\ndate: 2016-12-22 00:30:55\nupdated: 2016-12-22 00:50:55\ncategories:\n- 学习笔记\ntags:\n- java\n- 编程\n---\nday27授课目录：\n\n### 27.01_反射(类的加载概述和加载时机) ###\n* A:类的加载概述\n\t* 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。\n\t* 加载 \n\t\t* 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。\n\t* 连接\n\t\t* 验证 是否有正确的内部结构，并和其他类协调一致\n\t\t* 准备 负责为类的静态成员分配内存，并设置默认初始化值\n\t\t* 解析 将类的二进制数据中的符号引用替换为直接引用\n\t\t\n\t* 初始化 就是我们以前讲过的初始化步骤\n* B:加载时机\n\t* 创建类的实例\n\t* 访问类的静态变量，或者为静态变量赋值\n\t* 调用类的静态方法\n\t* 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n\t* 初始化某个类的子类\n\t* 直接使用java.exe命令来运行某个主类\n\n### 27.02_反射(类加载器的概述和分类) ###\n* A:类加载器的概述\n\t* 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。\n* B:类加载器的分类\n\t* Bootstrap ClassLoader 根类加载器\n\t* Extension ClassLoader 扩展类加载器\n\t* Sysetm ClassLoader 系统类加载器\n* C:类加载器的作用\n\t* Bootstrap ClassLoader 根类加载器\n\t\t* 也被称为引导类加载器，负责Java核心类的加载\n\t\t* 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中\n\t* Extension ClassLoader 扩展类加载器\n\t\t* 负责JRE的扩展目录中jar包的加载。\n\t\t* 在JDK中JRE的lib目录下ext目录\n\t* Sysetm ClassLoader 系统类加载器\n\t\t* 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径\n\n### 27.03_反射(反射概述) ###\n* A:反射概述\n\t* JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\n\t* 对于任意一个对象，都能够调用它的任意一个方法和属性；\n\t* 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\t* 要想解剖一个类,必须先要获取到该类的字节码文件对象。\n\t* 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。\n\n* B:三种方式\n\t* a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件\n\t* b:静态属性class,锁对象\n\t* c:Class类中静态方法forName(),读取配置文件\n* C:案例演示\n\t* 获取class文件对象的三种方式\n\n### 27.04_反射(Class.forName()读取配置文件举例) ###\n* 榨汁机(Juicer)榨汁的案例\n* 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze)\n\n\t\tpublic class Demo2_Reflect {\n\n\t\t\t/**\n\t\t\t * 榨汁机(Juicer)榨汁的案例\n\t\t\t * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze)\n\t\t\t * @throws Exception \n\t\t\t */\n\t\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t\t/*Juicer j = new Juicer();\n\t\t\t\t//j.run(new Apple());\n\t\t\t\tj.run(new Orange());*/\n\t\t\t\tBufferedReader br = new BufferedReader(new FileReader(\"config.properties\"));\t//创建输入流对象,关联配置文件\n\t\t\t\tClass<?> clazz = Class.forName(br.readLine());\t\t\t\t\t\t\t\t\t//读取配置文件一行内容,获取该类的字节码对象\n\t\t\t\tFruit f = (Fruit) clazz.newInstance();\t\t\t\t\t\t\t\t\t\t\t//通过字节码对象创建实例对象\n\t\t\t\tJuicer j = new Juicer();\n\t\t\t\tj.run(f);\n\t\t\t}\n\t\t\n\t\t}\n\t\tinterface Fruit {\n\t\t\tpublic void squeeze();\n\t\t}\n\t\t\n\t\tclass Apple implements Fruit {\n\t\t\tpublic void squeeze() {\n\t\t\t\tSystem.out.println(\"榨出一杯苹果汁儿\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass Orange implements Fruit {\n\t\t\tpublic void squeeze() {\n\t\t\t\tSystem.out.println(\"榨出一杯桔子汁儿\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass Juicer {\n\t\t\tpublic void run(Fruit f) {\n\t\t\t\tf.squeeze();\n\t\t\t}\n\t\t\n\t\t}\n###27.05_反射(通过反射获取带参构造方法并使用)###\n* Constructor\n\t* Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(\"张三\",20)方法创建对象\n\n\n###27.06_反射(通过反射获取成员变量并使用)###\n* Field\n\t* Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(\"name\")方法获取,通过set(obj, \"李四\")方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值\n\n###27.07_反射(通过反射获取方法并使用)###\n* Method\n\t* Class.getMethod(String, Class...) 和 Class.getDeclaredMethod(String, Class...)方法可以获取类中的指定方法,调用invoke(Object, Object...)可以调用该方法,Class.getMethod(\"eat\") invoke(obj) Class.getMethod(\"eat\",int.class) invoke(obj,10)\n\n###27.08_反射(通过反射越过泛型检查)###\n* A:案例演示\n\t* ArrayList<Integer>的一个对象，在这个集合中添加一个字符串数据，如何实现呢？\n\n###27.09_反射(通过反射写一个通用的设置某个对象的某个属性为指定的值)###\n* A:案例演示\n\t* public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。\n\n###27.10_反射(练习)###\n* 已知一个类，定义如下： \n\t * package cn.itcast.heima;\n\t * \t\tpublic class DemoClass {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tSystem.out.println(\"welcome to heima!\");\n\t\t\t\t}\n\t\t\t}\n\t * (1) 写一个Properties格式的配置文件，配置类的完整名称。 \n\t * (2) 写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，用反射的方式运行run方法。\n\n###27.11_反射(动态代理的概述和实现)###\n* A:动态代理概述\n\t* 代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。\n\t* 举例：春节回家买票让人代买\n\t* 动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理\n\t\t\n\t* 在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象\n\t* public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)\n\t* 最终会调用InvocationHandler的方法\n\t* InvocationHandler Object invoke(Object proxy,Method method,Object[] args)\n\n\n###27.12_设计模式(模版(Template)设计模式概述和使用)###\n* A:模版设计模式概述\n\t* 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现\n* B:优点和缺点\n\t* a:优点\n\t\t* 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求\n\t* b:缺点\n\t\t* 如果算法骨架有修改的话，则需要修改抽象类\n1,装饰\n2,单例\n3,简单工厂\n4,工厂方法\n5,适配器\n6,模版\n\n###27.13_JDK5新特性(自己实现枚举类)###\n* A:枚举概述\n\t* 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。\n* B:回想单例设计模式：单例类是一个类只有一个实例\n\t* 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。\n* C:案例演示\n\t* 自己实现枚举类\n1,自动拆装箱\n2,泛型\n3,可变参数\n4,静态导入\n5,增强for循环\n6,互斥锁\n7,枚举\n\t\t\n###27.14_JDK5新特性(通过enum实现枚举类)###\n* A:案例演示\n\t* 通过enum实现枚举类\n\n###27.15_JDK5新特性(枚举的注意事项)###\n* A:案例演示\n\t* 定义枚举类要用关键字enum\n\t* 所有枚举类都是Enum的子类\n\t* 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略\n\t* 枚举类可以有构造器，但必须是private的，它默认的也是private的。\n\t* 枚举类也可以有抽象方法，但是枚举项必须重写该方法\n\t* 枚举在switch语句中的使用\n\n###27.16_JDK5新特性(枚举类的常见方法)###\n* A:枚举类的常见方法\n\t* int ordinal()\n\t* int compareTo(E o)\n\t* String name()\n\t* String toString()\n\t* <T> T valueOf(Class<T> type,String name)\n\t* values() \n\t* 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便\n* B:案例演示\n\t* 枚举类的常见方法\n\n###27.17_JDK7新特性(JDK7的六个新特性回顾和讲解)###\n* A:二进制字面量\n* B:数字字面量可以出现下划线\n* C:switch 语句可以用字符串\n* D:泛型简化,菱形泛型\n* E:异常的多个catch合并,每个异常用或|\n* F:try-with-resources 语句\n\n###27.18_JDK8新特性(JDK8的新特性)###\n* 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰\t\n* 如果是静态的就不用了\n\n\t\tclass Test {\n\t\t\tpublic void run() {\n\t\t\t\tfinal int x = 10;\n\t\t\t\tclass Inner {\n\t\t\t\t\tpublic void method() {\n\t\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tInner i = new Inner();\n\t\t\t\ti.method();\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?\n\t\t因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用\n###27.19_day27总结###\n\n* 把今天的知识点总结一遍。","categories":[{"name":"学习笔记","path":"api/categories/学习笔记.json"}],"tags":[{"name":"java","path":"api/tags/java.json"},{"name":"编程","path":"api/tags/编程.json"}]}