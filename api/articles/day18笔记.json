{"title":"day18笔记","slug":"day18笔记","date":"2016-12-21T10:59:15.861Z","updated":"2016-12-21T10:22:20.679Z","comments":true,"path":"api/articles/day18笔记.json","excerpt":"","raw":"---\ntitle: day18笔记\n---\n###18.01_集合框架(Map集合概述和特点)\n* A:Map接口概述\n\t* 查看API可以知道：\n\t\t* 将键映射到值的对象\n\t\t* 一个映射不能包含重复的键\n\t\t* 每个键最多只能映射到一个值\n* B:Map接口和Collection接口的不同\n\t* Map是双列的,Collection是单列的\n\t* Map的键唯一,Collection的子体系Set是唯一的\n\t* Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效\n\t\n###18.02_集合框架(Map集合的功能概述)\n* A:Map集合的功能概述\n\t* a:添加功能\n\t\t* V put(K key,V value):添加元素。\n\t\t\t* 如果键是第一次存储，就直接存储元素，返回null\n\t\t\t* 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值\n\t* b:删除功能\n\t\t* void clear():移除所有的键值对元素\n\t\t* V remove(Object key)：根据键删除键值对元素，并把值返回\n\t* c:判断功能\n\t\t* boolean containsKey(Object key)：判断集合是否包含指定的键\n\t\t* boolean containsValue(Object value):判断集合是否包含指定的值\n\t\t* boolean isEmpty()：判断集合是否为空\n\t* d:获取功能\n\t\t* Set<Map.Entry<K,V>> entrySet():\n\t\t* V get(Object key):根据键获取值\n\t\t* Set<K> keySet():获取集合中所有键的集合\n\t\t* Collection<V> values():获取集合中所有值的集合\n\t* e:长度功能\n\t\t* int size()：返回集合中的键值对的个数\n\n\n###18.03_集合框架(Map集合的遍历之键找值)\n* A:键找值思路：\n\t* 获取所有键的集合\n\t* 遍历键的集合，获取到每一个键\n\t* 根据键找值\n* B:案例演示\n\t* Map集合的遍历之键找值\n\n\t\t\tHashMap<String, Integer> hm = new HashMap<>();\n\t\t\thm.put(\"张三\", 23);\n\t\t\thm.put(\"李四\", 24);\n\t\t\thm.put(\"王五\", 25);\n\t\t\thm.put(\"赵六\", 26);\n\t\t\t\n\t\t\t/*Set<String> keySet = hm.keySet();\t\t\t//获取集合中所有的键\n\t\t\tIterator<String> it = keySet.iterator();\t//获取迭代器\n\t\t\twhile(it.hasNext()) {\t\t\t\t\t\t//判断单列集合中是否有元素\n\t\t\t\tString key = it.next();\t\t\t\t\t//获取集合中的每一个元素,其实就是双列集合中的键\n\t\t\t\tInteger value = hm.get(key);\t\t\t//根据键获取值\n\t\t\t\tSystem.out.println(key + \"=\" + value);\t//打印键值对\n\t\t\t}*/\n\t\t\t\n\t\t\tfor(String key : hm.keySet()) {\t\t\t\t//增强for循环迭代双列集合第一种方式\n\t\t\t\tSystem.out.println(key + \"=\" + hm.get(key));\n\t\t\t}\n\t\n###18.04_集合框架(Map集合的遍历之键值对对象找键和值)\n* A:键值对对象找键和值思路：\n\t* 获取所有键值对对象的集合\n\t* 遍历键值对对象的集合，获取到每一个键值对对象\n\t* 根据键值对对象找键和值\n* B:案例演示\n\t* Map集合的遍历之键值对对象找键和值\n\t\n\t\t\tHashMap<String, Integer> hm = new HashMap<>();\n\t\t\thm.put(\"张三\", 23);\n\t\t\thm.put(\"李四\", 24);\n\t\t\thm.put(\"王五\", 25);\n\t\t\thm.put(\"赵六\", 26);\n\t\t\t/*Set<Map.Entry<String, Integer>> entrySet = hm.entrySet();\t//获取所有的键值对象的集合\n\t\t\tIterator<Entry<String, Integer>> it = entrySet.iterator();//获取迭代器\n\t\t\twhile(it.hasNext()) {\n\t\t\t\tEntry<String, Integer> en = it.next();\t\t\t\t//获取键值对对象\n\t\t\t\tString key = en.getKey();\t\t\t\t\t\t\t\t//根据键值对对象获取键\n\t\t\t\tInteger value = en.getValue();\t\t\t\t\t\t\t//根据键值对对象获取值\n\t\t\t\tSystem.out.println(key + \"=\" + value);\n\t\t\t}*/\n\t\t\t\n\t\t\tfor(Entry<String,Integer> en : hm.entrySet()) {\n\t\t\t\tSystem.out.println(en.getKey() + \"=\" + en.getValue());\n\t\t\t}\n\t\t\nC:源码分析\n\n###18.05_集合框架(HashMap集合键是Student值是String的案例)\n* A:案例演示\n\t* HashMap集合键是Student值是String的案例\n\n###18.06_集合框架(LinkedHashMap的概述和使用)\n* A:案例演示\n\t* LinkedHashMap的特点\n\t\t* 底层是链表实现的可以保证怎么存就怎么取\n\n###18.07_集合框架(TreeMap集合键是Student值是String的案例)\n* A:案例演示\n\t* TreeMap集合键是Student值是String的案例\n\n###18.08_集合框架(统计字符串中每个字符出现的次数)\n* A:案例演示\n\t* 需求：统计字符串中每个字符出现的次数\n\t\t\tString str = \"aaaabbbcccccccccc\";\n\t\t\tchar[] arr = str.toCharArray();\t\t\t\t\t\t//将字符串转换成字符数组\n\t\t\tHashMap<Character, Integer> hm = new HashMap<>();\t//创建双列集合存储键和值\n\t\t\t\n\t\t\tfor(char c : arr) {\t\t\t\t\t\t\t\t\t//遍历字符数组\n\t\t\t\t/*if(!hm.containsKey(c)) {\t\t\t\t\t\t//如果不包含这个键\n\t\t\t\t\thm.put(c, 1);\t\t\t\t\t\t\t\t//就将键和值为1添加\n\t\t\t\t}else {\t\t\t\t\t\t\t\t\t\t\t//如果包含这个键\n\t\t\t\t\thm.put(c, hm.get(c) + 1);\t\t\t\t\t//就将键和值再加1添加进来\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//hm.put(c, !hm.containsKey(c) ? 1 : hm.get(c) + 1);\n\t\t\t\tInteger i = !hm.containsKey(c) ? hm.put(c, 1) : hm.put(c, hm.get(c) + 1);\n\t\t\t\t\t\t}\n\t\t\t\n\t\t\tfor (Character key : hm.keySet()) {\t\t\t\t\t//遍历双列集合\n\t\t\t\tSystem.out.println(key + \"=\" + hm.get(key));\n\t\t\t}\n\n\n###18.09_集合框架(集合嵌套之HashMap嵌套HashMap)\n* A:案例演示\n\t* 集合嵌套之HashMap嵌套HashMap\n\n###18.10_集合框架(HashMap和Hashtable的区别)\n* A:面试题\n\t* HashMap和Hashtable的区别\n\t\t* Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高\n\t\t* Hashtable不可以存储null键和null值,HashMap可以存储null键和null值\n* B:案例演示\t\n\t* HashMap和Hashtable的区别\n\n###18.11_集合框架(Collections工具类的概述和常见方法讲解)\n* A:Collections类概述\n\t* 针对集合操作 的工具类\n* B:Collections成员方法\n* \n\t\tpublic static <T> void sort(List<T> list)\n\t\tpublic static <T> int binarySearch(List<?> list,T key)\n\t\tpublic static <T> T max(Collection<?> coll)\n\t\tpublic static void reverse(List<?> list)\n\t\tpublic static void shuffle(List<?> list)\n\n###18.12_集合框架(模拟斗地主洗牌和发牌)\n* A:案例演示\n\t* 模拟斗地主洗牌和发牌，牌没有排序\n\n\t\t\t//买一副扑克\n\t\t\tString[] num = {\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\"};\n\t\t\tString[] color = {\"方片\",\"梅花\",\"红桃\",\"黑桃\"};\n\t\t\tArrayList<String> poker = new ArrayList<>();\n\t\t\t\n\t\t\tfor(String s1 : color) {\n\t\t\t\tfor(String s2 : num) {\n\t\t\t\t\tpoker.add(s1.concat(s2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpoker.add(\"小王\");\n\t\t\tpoker.add(\"大王\");\n\t\t\t//洗牌\n\t\t\tCollections.shuffle(poker);\n\t\t\t//发牌\n\t\t\tArrayList<String> gaojin = new ArrayList<>();\n\t\t\tArrayList<String> longwu = new ArrayList<>();\n\t\t\tArrayList<String> me = new ArrayList<>();\n\t\t\tArrayList<String> dipai = new ArrayList<>();\n\t\t\t\n\t\t\tfor(int i = 0; i < poker.size(); i++) {\n\t\t\t\tif(i >= poker.size() - 3) {\n\t\t\t\t\tdipai.add(poker.get(i));\n\t\t\t\t}else if(i % 3 == 0) {\n\t\t\t\t\tgaojin.add(poker.get(i));\n\t\t\t\t}else if(i % 3 == 1) {\n\t\t\t\t\tlongwu.add(poker.get(i));\n\t\t\t\t}else {\n\t\t\t\t\tme.add(poker.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//看牌\n\t\t\t\n\t\t\tSystem.out.println(gaojin);\n\t\t\tSystem.out.println(longwu);\n\t\t\tSystem.out.println(me);\n\t\t\tSystem.out.println(dipai);\n\n###18.13_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的原理图解)\n* A:画图演示\n\t* 画图说明排序原理\n\n###18.14_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的代码实现)\n* A:案例演示\n\t* 模拟斗地主洗牌和发牌并对牌进行排序的代码实现\n* \n\t\t\t//买一副牌\n\t\t\tString[] num = {\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\",\"2\"};\n\t\t\tString[] color = {\"方片\",\"梅花\",\"红桃\",\"黑桃\"};\n\t\t\tHashMap<Integer, String> hm = new HashMap<>();\t\t\t//存储索引和扑克牌\n\t\t\tArrayList<Integer> list = new ArrayList<>();\t\t\t//存储索引\n\t\t\tint index = 0;\t\t\t\t\t\t\t\t\t\t\t//索引的开始值\n\t\t\tfor(String s1 : num) {\n\t\t\t\tfor(String s2 : color) {\n\t\t\t\t\thm.put(index, s2.concat(s1));\t\t\t\t\t//将索引和扑克牌添加到HashMap中\n\t\t\t\t\tlist.add(index);\t\t\t\t\t\t\t\t//将索引添加到ArrayList集合中\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\thm.put(index, \"小王\");\n\t\t\tlist.add(index);\n\t\t\tindex++;\n\t\t\thm.put(index, \"大王\");\n\t\t\tlist.add(index);\n\t\t\t//洗牌\n\t\t\tCollections.shuffle(list);\n\t\t\t//发牌\n\t\t\tTreeSet<Integer> gaojin = new TreeSet<>();\n\t\t\tTreeSet<Integer> longwu = new TreeSet<>();\n\t\t\tTreeSet<Integer> me = new TreeSet<>();\n\t\t\tTreeSet<Integer> dipai = new TreeSet<>();\n\t\t\t\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tif(i >= list.size() - 3) {\n\t\t\t\t\tdipai.add(list.get(i)); \t\t\t\t\t\t//将list集合中的索引添加到TreeSet集合中会自动排序\n\t\t\t\t}else if(i % 3 == 0) {\n\t\t\t\t\tgaojin.add(list.get(i));\n\t\t\t\t}else if(i % 3 == 1) {\n\t\t\t\t\tlongwu.add(list.get(i));\n\t\t\t\t}else {\n\t\t\t\t\tme.add(list.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//看牌\n\t\t\tlookPoker(\"高进\", gaojin, hm);\n\t\t\tlookPoker(\"龙五\", longwu, hm);\n\t\t\tlookPoker(\"冯佳\", me, hm);\n\t\t\tlookPoker(\"底牌\", dipai, hm);\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void lookPoker(String name,TreeSet<Integer> ts,HashMap<Integer, String> hm) {\n\t\t\tSystem.out.print(name + \"的牌是:\");\n\t\t\tfor (Integer index : ts) {\n\t\t\t\tSystem.out.print(hm.get(index) + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println();\n\t\t}\n###18.15_集合框架(泛型固定下边界)\n* ? super E\n\n###18.16_day18总结\n* 把今天的知识点总结一遍。\n\n","categories":[],"tags":[]}