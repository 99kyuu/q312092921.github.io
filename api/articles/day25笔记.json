{"title":"day25笔记","slug":"day25笔记","date":"2016-12-21T10:59:15.882Z","updated":"2016-12-21T10:23:31.301Z","comments":true,"path":"api/articles/day25笔记.json","excerpt":"","raw":"---\ntitle: day25笔记\n---\n###25.01_多线程(单例设计模式)(掌握)\n* 单例设计模式：保证类在内存中只有一个对象。\n\n* 如何保证类在内存中只有一个对象呢？\n\t* (1)控制类的创建，不让其他类来创建本类的对象。private\n\t* (2)在本类中定义一个本类的对象。Singleton s;\n\t* (3)提供公共的访问方式。  public static Singleton getInstance(){return s}\n* 单例写法两种：\n\t* (1)饿汉式 开发用这种方式。\n\t* \n\t\t\t//饿汉式\n\t\t\tclass Singleton {\n\t\t\t\t//1,私有构造函数\n\t\t\t\tprivate Singleton(){}\n\t\t\t\t//2,创建本类对象\n\t\t\t\tprivate static Singleton s = new Singleton();\n\t\t\t\t//3,对外提供公共的访问方法\n\t\t\t\tpublic static Singleton getInstance() {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void print() {\n\t\t\t\t\tSystem.out.println(\"11111111111\");\n\t\t\t\t}\n\t\t\t}\n\t* (2)懒汉式 面试写这种方式。多线程的问题？\n\t* \n\t\t\t//懒汉式,单例的延迟加载模式\n\t\t\tclass Singleton {\n\t\t\t\t//1,私有构造函数\n\t\t\t\tprivate Singleton(){}\n\t\t\t\t//2,声明一个本类的引用\n\t\t\t\tprivate static Singleton s;\n\t\t\t\t//3,对外提供公共的访问方法\n\t\t\t\tpublic static Singleton getInstance() {\n\t\t\t\t\tif(s == null)\n\t\t\t\t\t\t//线程1,线程2\n\t\t\t\t\t\ts = new Singleton();\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void print() {\n\t\t\t\t\tSystem.out.println(\"11111111111\");\n\t\t\t\t}\n\t\t\t}\n\t* (3)第三种格式\n\t* \n\t\t\tclass Singleton {\n\t\t\t\tprivate Singleton() {}\n\t\t\t\n\t\t\t\tpublic static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改\n\t\t\t}\n###25.02_多线程(Runtime类)\n* Runtime类是一个单例类\n\t* \n\t\t\tRuntime r = Runtime.getRuntime();\n\t\t\t//r.exec(\"shutdown -s -t 300\");\t\t//300秒后关机\n\t\t\tr.exec(\"shutdown -a\");\t\t\t\t//取消关机\n\n###25.03_多线程(Timer)(掌握)\n* Timer类:计时器\n\n\t\t\tpublic class Demo5_Timer {\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t * 计时器\n\t\t\t\t * @throws InterruptedException \n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) throws InterruptedException {\n\t\t\t\t\tTimer t = new Timer();\n\t\t\t\t\tt.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000);\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tSystem.out.println(new Date());\n\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclass MyTimerTask extends TimerTask {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tSystem.out.println(\"起床背英语单词\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n###25.04_多线程(两个线程间的通信)(掌握)\n* 1.什么时候需要通信\n\t* 多个线程并发执行时, 在默认情况下CPU是随机切换线程的\n\t* 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印\n* 2.怎么通信\n\t* 如果希望线程等待, 就调用wait()\n\t* 如果希望唤醒等待的线程, 就调用notify();\n\t* 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用\n\n###25.05_多线程(三个或三个以上间的线程通信)\n* 多个线程通信的问题\n\t* notify()方法是随机唤醒一个线程\n\t* notifyAll()方法是唤醒所有线程\n\t* JDK5之前无法唤醒指定的一个线程\n\t* 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件\n###25.06_多线程(JDK1.5的新特性互斥锁)(掌握)\n* 1.同步\n\t* 使用ReentrantLock类的lock()和unlock()方法进行同步\n* 2.通信\n\t* 使用ReentrantLock类的newCondition()方法可以获取Condition对象\n\t* 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法\n\t* 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了\n\n\n###25.07_多线程(线程组的概述和使用)(了解)\n* A:线程组概述\n\t* Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。\n\t* 默认情况下，所有的线程都属于主线程组。\n\t\t* public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组\n\t\t* public final String getName()//通过线程组对象获取他组的名字\n\t* 我们也可以给线程设置分组\n\t\t* 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字\n\t\t* 2,创建线程对象\n\t\t* 3,Thread(ThreadGroup?group, Runnable?target, String?name) \n\t\t* 4,设置整组的优先级或者守护线程\n\t* B:案例演示\n\t\t* 线程组的使用,默认是主线程组\n* \n\t\tMyRunnable mr = new MyRunnable();\n\t\tThread t1 = new Thread(mr, \"张三\");\n\t\tThread t2 = new Thread(mr, \"李四\");\n\t\t//获取线程组\n\t\t// 线程类里面的方法：public final ThreadGroup getThreadGroup()\n\t\tThreadGroup tg1 = t1.getThreadGroup();\n\t\tThreadGroup tg2 = t2.getThreadGroup();\n\t\t// 线程组里面的方法：public final String getName()\n\t\tString name1 = tg1.getName();\n\t\tString name2 = tg2.getName();\n\t\tSystem.out.println(name1);\n\t\tSystem.out.println(name2);\n\t\t// 通过结果我们知道了：线程默认情况下属于main线程组\n\t\t// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组\n\t\tSystem.out.println(Thread.currentThread().getThreadGroup().getName());\n\n\t* 自己设定线程组\n* \t\t\t\n\t\t// ThreadGroup(String name)\n\t\tThreadGroup tg = new ThreadGroup(\"这是一个新的组\");\n\n\t\tMyRunnable mr = new MyRunnable();\n\t\t// Thread(ThreadGroup group, Runnable target, String name)\n\t\tThread t1 = new Thread(tg, mr, \"张三\");\n\t\tThread t2 = new Thread(tg, mr, \"李四\");\n\t\t\n\t\tSystem.out.println(t1.getThreadGroup().getName());\n\t\tSystem.out.println(t2.getThreadGroup().getName());\n\t\t\n\t\t//通过组名称设置后台线程，表示该组的线程都是后台线程\n\t\ttg.setDaemon(true);\n###25.08_多线程(线程的五种状态)(掌握)\n* 看图说话\n* 新建,就绪,运行,阻塞,死亡\n\n###25.09_多线程(线程池的概述和使用)(了解)\n* A:线程池概述\n\t* 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池\n* B:内置线程池的使用概述\n\t* JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法\n\t\t* public static ExecutorService newFixedThreadPool(int nThreads)\n\t\t* public static ExecutorService newSingleThreadExecutor()\n\t\t* 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法\n\t\t* Future<?> submit(Runnable task)\n\t\t* <T> Future<T> submit(Callable<T> task)\n\t* 使用步骤：\n\t\t* 创建线程池对象\n\t\t* 创建Runnable实例\n\t\t* 提交Runnable实例\n\t\t* 关闭线程池\n\t* C:案例演示\n\t\t* 提交的是Runnable\n* \n\t\t// public static ExecutorService newFixedThreadPool(int nThreads)\n\t\tExecutorService pool = Executors.newFixedThreadPool(2);\n\n\t\t// 可以执行Runnable对象或者Callable对象代表的线程\n\t\tpool.submit(new MyRunnable());\n\t\tpool.submit(new MyRunnable());\n\n\t\t//结束线程池\n\t\tpool.shutdown();\n\t\t\n###25.10_多线程(多线程程序实现的方式3)(了解)\n* 提交的是Callable\n\n* \n\t\t// 创建线程池对象\n\t\tExecutorService pool = Executors.newFixedThreadPool(2);\n\n\t\t// 可以执行Runnable对象或者Callable对象代表的线程\n\t\tFuture<Integer> f1 = pool.submit(new MyCallable(100));\n\t\tFuture<Integer> f2 = pool.submit(new MyCallable(200));\n\n\t\t// V get()\n\t\tInteger i1 = f1.get();\n\t\tInteger i2 = f2.get();\n\n\t\tSystem.out.println(i1);\n\t\tSystem.out.println(i2);\n\n\t\t// 结束\n\t\tpool.shutdown();\n\n\t\tpublic class MyCallable implements Callable<Integer> {\n\n\t\t\tprivate int number;\n\t\t\n\t\t\tpublic MyCallable(int number) {\n\t\t\t\tthis.number = number;\n\t\t\t}\n\t\t\n\t\t\t@Override\n\t\t\tpublic Integer call() throws Exception {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int x = 1; x <= number; x++) {\n\t\t\t\t\tsum += x;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\n\t\t}\n* 多线程程序实现的方式3的好处和弊端\n\t* 好处：\n\t\t* 可以有返回值\n\t\t* 可以抛出异常\n\t\t\n\t* 弊端：\n\t\t* 代码比较复杂，所以一般不用\n\n\n###25.11_设计模式(简单工厂模式概述和使用)(了解)\n* A:简单工厂模式概述\n\t* 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例\n* B:优点\n\t* 客户端不需要在负责对象的创建，从而明确了各个类的职责\n* C:缺点\n\t* 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护\n* D:案例演示\n\t* 动物抽象类：public abstract Animal { public abstract void eat(); }\n\t* 具体狗类：public class Dog extends Animal {}\n\t* 具体猫类：public class Cat extends Animal {}\n\t* 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。\n* \n\t\tpublic class AnimalFactory {\n\t\t\tprivate AnimalFactory(){}\n\t\t\n\t\t\t//public static Dog createDog() {return new Dog();}\n\t\t\t//public static Cat createCat() {return new Cat();}\n\t\t\n\t\t\t//改进\n\t\t\tpublic static Animal createAnimal(String animalName) {\n\t\t\t\tif(“dog”.equals(animalName)) {}\n\t\t\t\telse if(“cat”.equals(animale)) {\n\t\t\n\t\t\t\t}else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n###25.12_设计模式(工厂方法模式的概述和使用)(了解)\n* A:工厂方法模式概述\n\t* 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。\n* B:优点\n\t* 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性\n* C:缺点\n\t* 需要额外的编写代码，增加了工作量\n* D:案例演示\n* \n\t\t动物抽象类：public abstract Animal { public abstract void eat(); }\n\t\t工厂接口：public interface Factory {public abstract Animal createAnimal();}\n\t\t具体狗类：public class Dog extends Animal {}\n\t\t具体猫类：public class Cat extends Animal {}\n\t\t开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。\n\t\t狗工厂：public class DogFactory implements Factory {\n\t\t\tpublic Animal createAnimal() {…}\n\t\t        }\n\t\t猫工厂：public class CatFactory implements Factory {\n\t\t\tpublic Animal createAnimal() {…}\n\t\t        }  \n\n###25.13_GUI(如何创建一个窗口并显示)\n* Graphical User Interface(图形用户接口)。\n* \n\t\tFrame  f = new Frame(“my window”);\n\t\tf.setLayout(new FlowLayout());//设置布局管理器\n\t\tf.setSize(500,400);//设置窗体大小\n\t\tf.setLocation(300,200);//设置窗体出现在屏幕的位置\n\t\tf.setIconImage(Toolkit.getDefaultToolkit().createImage(\"qq.png\"));\n\t\tf.setVisible(true);\n\n###25.14_GUI(布局管理器)\n* FlowLayout（流式布局管理器）\n\t* 从左到右的顺序排列。\n\t* Panel默认的布局管理器。\n* BorderLayout（边界布局管理器）\n\t* 东，南，西，北，中\n\t* Frame默认的布局管理器。\n* GridLayout（网格布局管理器）\n\t* 规则的矩阵\n* CardLayout（卡片布局管理器）\n\t* 选项卡\n* GridBagLayout（网格包布局管理器）\n\t* 非规则的矩阵\n###25.15_GUI(窗体监听)\n\tFrame f = new Frame(\"我的窗体\");\n\t//事件源是窗体,把监听器注册到事件源上\n\t//事件对象传递给监听器\n\tf.addWindowListener(new WindowAdapter() {\n\t          public void windowClosing(WindowEvent e) {\n\t                     //退出虚拟机,关闭窗口\n\t\t\tSystem.exit(0);\n\t\t}\n\t});\n\n###25.16_GUI(鼠标监听)\n###25.17_GUI(键盘监听和键盘事件)\n###25.18_GUI(动作监听)\n###25.19_设计模式(适配器设计模式)(掌握)\n* a.什么是适配器\n\t* 在使用监听器的时候, 需要定义一个类事件监听器接口.\n\t* 通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.\n\t* 适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.\n* b.适配器原理\n\t* 适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.\n\t* 适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的\n\t* 目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.\n###25.20_GUI(需要知道的) \n* 事件处理\n\t* 事件: 用户的一个操作\n\t* 事件源: 被操作的组件\n\t* 监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法\n###25.21_day25总结\n\t把今天的知识点总结一遍。","categories":[],"tags":[]}