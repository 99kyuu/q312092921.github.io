{"title":"day22笔记","slug":"day22笔记","date":"2016-12-21T10:59:15.872Z","updated":"2016-12-21T10:23:31.288Z","comments":true,"path":"api/articles/day22笔记.json","excerpt":"","raw":"---\ntitle: day22笔记\n---\n###22.01_IO流(序列流)(了解)\n* 1.什么是序列流\n\t* 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.\n* 2.使用方式\n\t* 整合两个: SequenceInputStream(InputStream, InputStream)\n\t* \n\t\t\tFileInputStream fis1 = new FileInputStream(\"a.txt\");\t\t\t//创建输入流对象,关联a.txt\n\t\t\tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t\t\t//创建输入流对象,关联b.txt\n\t\t\tSequenceInputStream sis = new SequenceInputStream(fis1, fis2);\t//将两个流整合成一个流\n\t\t\tFileOutputStream fos = new FileOutputStream(\"c.txt\");\t\t\t//创建输出流对象,关联c.txt\n\t\t\t\n\t\t\tint b;\n\t\t\twhile((b = sis.read()) != -1) {\t\t\t\t\t\t\t\t\t//用整合后的读\n\t\t\t\tfos.write(b);\t\t\t\t\t\t\t\t\t\t\t\t//写到指定文件上\n\t\t\t}\n\t\t\t\n\t\t\tsis.close();\n\t\t\tfos.close(); \n###22.02_IO流(序列流整合多个)(了解)\n* 整合多个: SequenceInputStream(Enumeration)\n* \n\t\tFileInputStream fis1 = new FileInputStream(\"a.txt\");\t//创建输入流对象,关联a.txt\n\t\tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t//创建输入流对象,关联b.txt\n\t\tFileInputStream fis3 = new FileInputStream(\"c.txt\");\t//创建输入流对象,关联c.txt\n\t\tVector<InputStream> v = new Vector<>();\t\t\t\t\t//创建vector集合对象\n\t\tv.add(fis1);\t\t\t\t\t\t\t\t\t\t\t//将流对象添加\n\t\tv.add(fis2);\n\t\tv.add(fis3);\n\t\tEnumeration<InputStream> en = v.elements();\t\t\t\t//获取枚举引用\n\t\tSequenceInputStream sis = new SequenceInputStream(en);\t//传递给SequenceInputStream构造\n\t\tFileOutputStream fos = new FileOutputStream(\"d.txt\");\n\t\tint b;\n\t\twhile((b = sis.read()) != -1) {\n\t\t\tfos.write(b);\n\t\t}\n\t\n\t\tsis.close();\n\t\tfos.close();\n\n###22.03_IO流(内存输出流*****)(掌握)\n* 1.什么是内存输出流\n\t* 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据\n* 2.使用方式\n\t* 创建对象: new ByteArrayOutputStream()\n\t* 写出数据: write(int), write(byte[])\n\t* 获取数据: toByteArray()\n\t* \n\t\t\tFileInputStream fis = new FileInputStream(\"a.txt\");\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tint b;\n\t\t\twhile((b = fis.read()) != -1) {\n\t\t\t\tbaos.write(b);\n\t\t\t}\n\t\t\t\n\t\t\t//byte[] newArr = baos.toByteArray();\t\t\t\t//将内存缓冲区中所有的字节存储在newArr中\n\t\t\t//System.out.println(new String(newArr));\n\t\t\tSystem.out.println(baos);\n\t\t\tfis.close();\n###22.04_IO流(内存输出流之黑马面试题)(掌握)\n* 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)\n* \n\t\t\tFileInputStream fis = new FileInputStream(\"a.txt\");\t\t\t\t//创建字节输入流,关联a.txt\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\t\t//创建内存输出流\n\t\t\tbyte[] arr = new byte[5];\t\t\t\t\t\t\t\t\t\t//创建字节数组,大小为5\n\t\t\tint len;\n\t\t\twhile((len = fis.read(arr)) != -1) {\t\t\t\t\t\t\t//将文件上的数据读到字节数组中\n\t\t\t\tbaos.write(arr, 0, len);\t\t\t\t\t\t\t\t\t//将字节数组的数据写到内存缓冲区中\n\t\t\t}\n\t\t\tSystem.out.println(baos);\t\t\t\t\t\t\t\t\t\t//将内存缓冲区的内容转换为字符串打印\n\t\t\tfis.close();\n###22.05_IO流(随机访问流概述和读写数据)(了解)\n* A:随机访问流概述\n\t* RandomAccessFile概述\n\t* RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。\n\t* 支持对随机访问文件的读取和写入。\n\n* B:read(),write(),seek()\n\t\n###22.06_IO流(对象操作流ObjecOutputStream)(了解)\n* 1.什么是对象操作流\n\t* 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.\n* 2.使用方式\n\t* 写出: new ObjectOutputStream(OutputStream), writeObject()\n\n\t\t\tpublic class Demo3_ObjectOutputStream {\n\t\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t * @throws IOException \n\t\t\t\t * 将对象写出,序列化\n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) throws IOException {\n\t\t\t\t\tPerson p1 = new Person(\"张三\", 23);\n\t\t\t\t\tPerson p2 = new Person(\"李四\", 24);\n\t\t\t//\t\tFileOutputStream fos = new FileOutputStream(\"e.txt\");\n\t\t\t//\t\tfos.write(p1);\n\t\t\t//\t\tFileWriter fw = new FileWriter(\"e.txt\");\n\t\t\t//\t\tfw.write(p1);\n\t\t\t\t\t//无论是字节输出流,还是字符输出流都不能直接写出对象\n\t\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"e.txt\"));//创建对象输出流\n\t\t\t\t\toos.writeObject(p1);\n\t\t\t\t\toos.writeObject(p2);\n\t\t\t\t\toos.close();\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n###22.07_IO流(对象操作流ObjectInputStream)(了解)\n* 读取: new ObjectInputStream(InputStream), readObject()\n\t* \n\t\t\tpublic class Demo3_ObjectInputStream {\n\n\t\t\t\t/**\n\t\t\t\t * @param args\n\t\t\t\t * @throws IOException \n\t\t\t\t * @throws ClassNotFoundException \n\t\t\t\t * @throws FileNotFoundException \n\t\t\t\t * 读取对象,反序列化\n\t\t\t\t */\n\t\t\t\tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"e.txt\"));\n\t\t\t\t\tPerson p1 = (Person) ois.readObject();\n\t\t\t\t\tPerson p2 = (Person) ois.readObject();\n\t\t\t\t\tSystem.out.println(p1);\n\t\t\t\t\tSystem.out.println(p2);\n\t\t\t\t\tois.close();\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\n###22.08_IO流(对象操作流优化)(了解)\n*　将对象存储在集合中写出\n\n\tPerson p1 = new Person(\"张三\", 23);\n\tPerson p2 = new Person(\"李四\", 24);\n\tPerson p3 = new Person(\"马哥\", 18);\n\tPerson p4 = new Person(\"辉哥\", 20);\n\t\n\tArrayList<Person> list = new ArrayList<>();\n\tlist.add(p1);\n\tlist.add(p2);\n\tlist.add(p3);\n\tlist.add(p4);\n\t\n\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"f.txt\"));\n\toos.writeObject(list);\t\t\t\t\t\t\t\t\t//写出集合对象\n\t\n\toos.close();\n* 读取到的是一个集合对象\n\n\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"f.txt\"));\n\t\t\tArrayList<Person> list = (ArrayList<Person>)ois.readObject();\t//泛型在运行期会被擦除,索引运行期相当于没有泛型\n\t\t//想去掉黄色可以加注解\t\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfor (Person person : list) {\n\t\t\t\tSystem.out.println(person);\n\t\t\t}\n\t\t\n\t\tois.close();\n###22.09_IO流(加上id号)(了解)\n* 注意\n\t* 要写出的对象必须实现Serializable接口才能被序列化\n\t* 不用必须加id号\n\n###22.10_IO流(数据输入输出流)(了解)\n* 1.什么是数据输入输出流\n\t* DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据\n\t* 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.\n* 2.使用方式\n\t* DataOutputStream(OutputStream), writeInt(), writeLong() \n\n\t\t\tDataOutputStream dos = new DataOutputStream(new FileOutputStream(\"b.txt\"));\n\t\t\tdos.writeInt(997);\n\t\t\tdos.writeInt(998);\n\t\t\tdos.writeInt(999);\n\t\t\t\n\t\t\tdos.close();\n\t* DataInputStream(InputStream), readInt(), readLong()\n\n\t\t\tDataInputStream dis = new DataInputStream(new FileInputStream(\"b.txt\"));\n\t\t\tint x = dis.readInt();\n\t\t\tint y = dis.readInt();\n\t\t\tint z = dis.readInt();\n\t\t\tSystem.out.println(x);\n\t\t\tSystem.out.println(y);\n\t\t\tSystem.out.println(z);\n\t\t\tdis.close();\n\n###22.11_IO流(打印流的概述和特点)(掌握)\n* 1.什么是打印流\n\t* 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式\n\t* System.out就是一个PrintStream, 其默认向控制台输出信息\n\n\t\t\tPrintStream ps = System.out;\n\t\t\tps.println(97);\t\t\t\t\t//其实底层用的是Integer.toString(x),将x转换为数字字符串打印\n\t\t\tps.println(\"xxx\");\n\t\t\tps.println(new Person(\"张三\", 23));\n\t\t\tPerson p = null;\n\t\t\tps.println(p);\t\t\t\t\t//如果是null,就返回null,如果不是null,就调用对象的toString()\n* 2.使用方式\n\t* 打印: print(), println()\n\t* 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) \n\t* 打印流只操作数据目的\n\n\t\t\tPrintWriter pw = new PrintWriter(new FileOutputStream(\"g.txt\"), true);\n\t\t\tpw.write(97);\n\t\t\tpw.print(\"大家好\");\n\t\t\tpw.println(\"你好\");\t\t\t\t//自动刷出,只针对的是println方法\n\t\t\tpw.close();\n\n###22.12_IO流(标准输入输出流概述和输出语句)\n* 1.什么是标准输入输出流(掌握)\n\t* System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据\n\t* System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据\n* 2.修改标准输入输出流(了解)\n\t* 修改输入流: System.setIn(InputStream)\n\t* 修改输出流: System.setOut(PrintStream)\n\t* \n\t\t\tSystem.setIn(new FileInputStream(\"a.txt\"));\t\t\t\t//修改标准输入流\n\t\t\tSystem.setOut(new PrintStream(\"b.txt\"));\t\t\t\t//修改标准输出流\n\t\t\t\n\t\t\tInputStream in = System.in;\t\t\t\t\t\t\t\t//获取标准输入流\n\t\t\tPrintStream ps = System.out;\t\t\t\t\t\t\t//获取标准输出流\n\t\t\tint b;\n\t\t\twhile((b = in.read()) != -1) {\t\t\t\t\t\t\t//从a.txt上读取数据\n\t\t\t\tps.write(b);\t\t\t\t\t\t\t\t\t\t//将数据写到b.txt上\n\t\t\t}\n\t\t\t\n\t\t\tin.close();\n\t\t\tps.close();\n\n###22.13_IO流(修改标准输入输出流拷贝图片)(了解)\n\t\tSystem.setIn(new FileInputStream(\"IO图片.png\"));\t\t//改变标准输入流\n\t\tSystem.setOut(new PrintStream(\"copy.png\")); \t\t//改变标准输出流\n\t\t\n\t\tInputStream is = System.in;\t\t\t\t\t\t\t//获取标准输入流\n\t\tPrintStream ps = System.out;\t\t\t\t\t\t//获取标准输出流\n\t\t\n\t\tint len;\n\t\tbyte[] arr = new byte[1024 * 8];\n\t\t\n\t\twhile((len = is.read(arr)) != -1) {\n\t\t\tps.write(arr, 0, len);\n\t\t}\n\t\t\n\t\tis.close();\n\t\tps.close();\n###22.14_IO流(两种方式实现键盘录入)(了解)\n* A:BufferedReader的readLine方法。\n\t* BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n* B:Scanner\n\n\n###22.15_IO流(Properties的概述和作为Map集合的使用)(了解)\n* A:Properties的概述\n\t* Properties 类表示了一个持久的属性集。\n\t* Properties 可保存在流中或从流中加载。\n\t* 属性列表中每个键及其对应值都是一个字符串。 \n* B:案例演示\n\t* Properties作为Map集合的使用\n\t\n###22.16_IO流(Properties的特殊功能使用)(了解)\n* A:Properties的特殊功能\n\t* public Object setProperty(String key,String value)\n\t* public String getProperty(String key)\n\t* public Enumeration<String> stringPropertyNames()\n* B:案例演示\n\t* Properties的特殊功能\n\t\n###22.17_IO流(Properties的load()和store()功能)(了解)\n* A:Properties的load()和store()功能\n* B:案例演示\n\t* Properties的load()和store()功能\n\t\n\n###22.18_day22总结\n* 把今天的知识点总结一遍。","categories":[],"tags":[]}