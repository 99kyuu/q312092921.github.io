{"title":"day15笔记","slug":"day15笔记","date":"2016-12-21T10:59:08.094Z","updated":"2016-12-21T10:22:20.713Z","comments":true,"path":"api/articles/day15笔记.json","excerpt":"","raw":"---\ntitle: day15笔记\n---\n###15.01_集合框架(对象数组的概述和使用)\n* A:案例演示\n\t* 需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。\n* \n\t\tStudent[] arr = new Student[5];\t\t\t\t\t//存储学生对象\n\t\tarr[0] = new Student(\"张三\", 23);\n\t\tarr[1] = new Student(\"李四\", 24);\n\t\tarr[2] = new Student(\"王五\", 25);\n\t\tarr[3] = new Student(\"赵六\", 26);\n\t\tarr[4] = new Student(\"马哥\", 20);\n\t\t\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.println(arr[i]);\n\t\t}\n\t\t\n* B:画图演示\n\t* 把学生数组的案例画图讲解\n\t* 数组和集合存储引用数据类型,存的都是地址值\n\n###15.02_集合框架(集合的由来及集合继承体系图)\n* A:集合的由来\n\t* 数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 \n* B:数组和集合的区别\n\t* 区别1 : \n\t\t* 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值\n\t\t* 集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象\n\t* 区别2:\n\t\t* 数组长度是固定的,不能自动增长\n\t\t* 集合的长度的是可变的,可以根据元素的增加而增长\n* C:数组和集合什么时候用\n\t\t* 1,如果元素个数是固定的推荐用数组\n\t\t* 2,如果元素个数不是固定的推荐用集合\n* D:集合继承体系图\n\n###15.03_集合框架(Collection集合的基本功能测试)\n* A:案例演示\t\n* \n\t\t基本功能演示\n\t\t\n\t\tboolean add(E e)\n\t\tboolean remove(Object o)\n\t\tvoid clear()\n\t\tboolean contains(Object o)\n\t\tboolean isEmpty()\n\t\tint size()\n\n* B:注意:\n* \n\t\tcollectionXxx.java使用了未经检查或不安全的操作.\n\t\t注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.\n\t\tjava编译器认为该程序存在安全隐患\n\t\t温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了\n\t  \n###15.04_集合框架(集合的遍历之集合转数组遍历)\n* A:集合的遍历\n\t* 其实就是依次获取集合中的每一个元素。\n* B:案例演示\n\t* 把集合转成数组，可以实现集合的遍历\n\t* toArray()\n\t*\n\t\t\n\t\t\tCollection coll = new ArrayList();\n\t\t\tcoll.add(new Student(\"张三\",23));\t\t//Object obj = new Student(\"张三\",23);\n\t\t\tcoll.add(new Student(\"李四\",24));\n\t\t\tcoll.add(new Student(\"王五\",25));\n\t\t\tcoll.add(new Student(\"赵六\",26));\n\t\t\t\n\t\t\tObject[] arr = coll.toArray();\t\t\t\t//将集合转换成数组\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tStudent s = (Student)arr[i];\t\t\t//强转成Student\n\t\t\t\tSystem.out.println(s.getName() + \",\" + s.getAge());\n\t\t\t}\n\n###15.05_集合框架(Collection集合的带All功能测试)\n* A:案例演示\n* \n\t\t带All的功能演示\n\t\t\n\t\tboolean addAll(Collection c)\n\t\tboolean removeAll(Collection c)\n\t\tboolean containsAll(Collection c)\n\t\tboolean retainAll(Collection c)\n\n\n###15.06_集合框架(集合的遍历之迭代器遍历)\n* A:迭代器概述\n\t* 集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) \n* B:案例演示\n\t* 迭代器的使用\n\t\t\n\t\t\tCollection c = new ArrayList();\n\t\t\tc.add(\"a\");\n\t\t\tc.add(\"b\");\n\t\t\tc.add(\"c\");\n\t\t\tc.add(\"d\");\n\t\t\t\n\t\t\tIterator it = c.iterator();\t\t\t\t\t\t//获取迭代器的引用\n\t\t\twhile(it.hasNext()) {\t\t\t\t\t\t\t//集合中的迭代方法(遍历)\n\t\t\t\tSystem.out.println(it.next());\n\t\t\t}\n\t\n\t\t\t\n###15.07_集合框架(Collection存储自定义对象并遍历)\n* A:案例演示\n\t* Collection存储自定义对象并用迭代器遍历\n\t* \n\t\t\tCollection c = new ArrayList();\n\t\t\t\n\t\t\tc.add(new Student(\"张三\",23));\n\t\t\tc.add(new Student(\"李四\",24));\n\t\t\tc.add(new Student(\"王五\",25));\n\t\t\tc.add(new Student(\"赵六\",26));\n\t\t\tc.add(new Student(\"赵六\",26));\n\t\t\t\n\t\t\tfor(Iterator it = c.iterator();it.hasNext();) {\n\t\t\t\tStudent s = (Student)it.next();\t\t\t\t\t\t//向下转型\n\t\t\t\tSystem.out.println(s.getName() + \",\" + s.getAge());\t//获取对象中的姓名和年龄\n\t\t\t}\n\t\t\tSystem.out.println(\"------------------------------\");\n\t\t\tIterator it = c.iterator();\t\t\t\t\t\t\t\t//获取迭代器\n\t\t\twhile(it.hasNext()) {\t\t\t\t\t\t\t\t\t//判断集合中是否有元素\n\t\t\t\t//System.out.println(((Student)(it.next())).getName() + \",\" + ((Student)(it.next())).getAge());\n\t\t\t\tStudent s = (Student)it.next();\t\t\t\t\t\t//向下转型\n\t\t\t\tSystem.out.println(s.getName() + \",\" + s.getAge());\t//获取对象中的姓名和年龄\n\t\t\t}\n\t\t\n\n###15.08_集合框架(迭代器的原理及源码解析)(了解)\n* A:迭代器原理\n\t* 迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 \n* B:迭代器源码解析\n\t* 1,在eclipse中ctrl + shift + t找到ArrayList类\n\t* 2,ctrl+o查找iterator()方法\n\t* 3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口\n\t* 4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 \n\n###15.09_集合框架(List集合的特有功能概述和测试)\n* A:List集合的特有功能概述\n\t* void add(int index,E element)\n\t* E remove(int index)\n\t* E get(int index)\n\t* E set(int index,E element)\n\n###15.10_集合框架(List集合存储学生对象并遍历)\n* A:案例演示\n\t* 通过size()和get()方法结合使用遍历。\n\n\t\t\tList list = new ArrayList();\n\t\t\tlist.add(new Student(\"张三\", 18));\n\t\t\tlist.add(new Student(\"李四\", 18));\n\t\t\tlist.add(new Student(\"王五\", 18));\n\t\t\tlist.add(new Student(\"赵六\", 18));\n\t\t\t\n\t\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\t\tStudent s = (Student)list.get(i);\n\t\t\t\tSystem.out.println(s.getName() + \",\" + s.getAge());\n\t\t\t}\n\n###15.11_集合框架(并发修改异常产生的原因及解决方案)\n* A:案例演示\n\t* 需求：我有一个集合，请问，我想判断里面有没有\"world\"这个元素，如果有，我就添加一个\"javaee\"元素，请写代码实现。\n\n\t\t\tList list = new ArrayList();\n\t\t\tlist.add(\"a\");\n\t\t\tlist.add(\"b\");\n\t\t\tlist.add(\"world\");\n\t\t\tlist.add(\"d\");\n\t\t\tlist.add(\"e\");\n\t\t\t\n\t\t\t/*Iterator it = list.iterator();\n\t\t\twhile(it.hasNext()) {\n\t\t\t\tString str = (String)it.next();\n\t\t\t\tif(str.equals(\"world\")) {\n\t\t\t\t\tlist.add(\"javaee\");\t\t\t//这里会抛出ConcurrentModificationException并发修改异常\n\t\t\t\t}\n\t\t\t}*/\n\t\t\t\n\t\t\t\n* B:ConcurrentModificationException出现\n\t* 迭代器遍历，集合修改集合\n* C:解决方案\n\t* a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)\n\t* b:集合遍历元素，集合修改元素\n\n\t\t\tListIterator lit = list.listIterator();\t\t//如果想在遍历的过程中添加元素,可以用ListIterator中的add方法\n\t\t\twhile(lit.hasNext()) {\n\t\t\t\tString str = (String)lit.next();\n\t\t\t\tif(str.equals(\"world\")) {\n\t\t\t\t\tlit.add(\"javaee\");\t\n\t\t\t\t\t//list.add(\"javaee\");\n\t\t\t\t}\n\t\t\t}\n\n###15.12_集合框架(ListIterator)(了解)\n* boolean hasNext()是否有下一个\n* boolean hasPrevious()是否有前一个\n* Object next()返回下一个元素\n* Object previous();返回上一个元素\n\n###15.13_集合框架(Vector的特有功能)(了解)\n* A:Vector类概述\n* B:Vector类特有功能\n\t* public void addElement(E obj)\n\t* public E elementAt(int index)\n\t* public Enumeration elements()\n* C:案例演示\t\n\t* Vector的迭代\n\n\t\t\tVector v = new Vector();\t\t\t\t//创建集合对象,List的子类\n\t\t\tv.addElement(\"a\");\n\t\t\tv.addElement(\"b\");\n\t\t\tv.addElement(\"c\");\n\t\t\tv.addElement(\"d\");\n\t\t\t\n\t\t\t//Vector迭代\n\t\t\tEnumeration en = v.elements();\t\t\t//获取枚举\n\t\t\twhile(en.hasMoreElements()) {\t\t\t//判断集合中是否有元素\n\t\t\t\tSystem.out.println(en.nextElement());//获取集合中的元素\n\t\t\t}\n\n###15.14_集合框架(数据结构之数组和链表)\n* A:数组\n\t* 查询快修改也快\n\t* 增删慢\n* B:链表\n\t* 查询慢,修改也慢\n\t* 增删快\n\n###15.15_集合框架(List的三个子类的特点)\n* A:List的三个子类的特点\n* \n\t\tArrayList:\n\t\t\t底层数据结构是数组，查询快，增删慢。\n\t\t\t线程不安全，效率高。\n\t\tVector:\n\t\t\t底层数据结构是数组，查询快，增删慢。\n\t\t\t线程安全，效率低。\n\t\tVector相对ArrayList查询慢(线程安全的)\n\t\tVector相对LinkedList增删慢(数组结构)\n\t\tLinkedList:\n\t\t\t底层数据结构是链表，查询慢，增删快。\n\t\t\t线程不安全，效率高。\n\n\t\tVector和ArrayList的区别\n\t\t\tVector是线程安全的,效率低\n\t\t\tArrayList是线程不安全的,效率高\n\t\t共同点:都是数组实现的\n\t\tArrayList和LinkedList的区别\n\t\t\tArrayList底层是数组结果,查询和修改快\n\t\t\tLinkedList底层是链表结构的,增和删比较快,查询和修改比较慢\n\t\t共同点:都是线程不安全的\n* B:List有三个儿子，我们到底使用谁呢?\n\t\t查询多用ArrayList\n\t\t增删多用LinkedList\n\t\t如果都多ArrayList\n###15.16_day15总结\n把今天的知识点总结一遍。","categories":[],"tags":[]}