{"title":"day17笔记","slug":"day17笔记","date":"2016-12-21T10:59:15.858Z","updated":"2016-12-21T10:22:20.673Z","comments":true,"path":"api/articles/day17笔记.json","excerpt":"","raw":"---\ntitle: day17笔记\n---\n###17.01_集合框架(HashSet存储字符串并遍历)\n* A:Set集合概述及特点\n\t* 通过API查看即可\n* B:案例演示\n\t* HashSet存储字符串并遍历\n\t* \n\t\t \tHashSet<String> hs = new HashSet<>();\n\t\t\tboolean b1 = hs.add(\"a\");\n\t\t\tboolean b2 = hs.add(\"a\");\t\t\t//当存储不成功的时候,返回false\n\t\t\t\n\t\t\tSystem.out.println(b1);\n\t\t\tSystem.out.println(b2);\n\t\t\tfor(String s : hs) {\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\n###17.02_集合框架(HashSet存储自定义对象保证元素唯一性)\n* A:案例演示\n\t* 存储自定义对象，并保证元素唯一性。\n\n\t\t\tHashSet<Person> hs = new HashSet<>();\n\t\t\ths.add(new Person(\"张三\", 23));\n\t\t\ths.add(new Person(\"张三\", 23));\n\t\t\ths.add(new Person(\"李四\", 23));\n\t\t\ths.add(new Person(\"李四\", 23));\n\t\t\ths.add(new Person(\"王五\", 23));\n\t\t\ths.add(new Person(\"赵六\", 23));\n* 重写hashCode()和equals()方法\n###17.03_集合框架(HashSet存储自定义对象保证元素唯一性图解及代码优化)\n* A:画图演示\n\t* 画图说明比较过程\n* B:代码优化\n\t* 为了减少比较，优化hashCode()代码写法。\n\t* 最终版就是自动生成即可。\n\n###17.04_集合框架(HashSet如何保证元素唯一性的原理)\n* 1.HashSet原理\n\t* 我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数\n\t* 当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象\n\t\t* 如果没有哈希值相同的对象就直接存入集合\n\t\t* 如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存\n* 2.将自定义类的对象存入HashSet去重复\n\t* 类中必须重写hashCode()和equals()方法\n\t* hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)\n\t* equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储\n\n###17.05_集合框架(LinkedHashSet的概述和使用)\n* A:LinkedHashSet的特点\n* B:案例演示\n\t* LinkedHashSet的特点\n\t\t* 可以保证怎么存就怎么取 \n\n###17.06_集合框架(产生10个1-20之间的随机数要求随机数不能重复)\n* A:案例演示\n\t* 需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。\n\t* \n\t\t\tHashSet<Integer> hs = new HashSet<>();\t\t//创建集合对象\n\t\t\tRandom r = new Random();\t\t\t\t\t//创建随机数对象\n\t\t\t\n\t\t\twhile(hs.size() < 10) {\n\t\t\t\tint num = r.nextInt(20) + 1;\t\t\t//生成1到20的随机数\n\t\t\t\ths.add(num);\n\t\t\t}\n\t\t\t\n\t\t\tfor (Integer integer : hs) {\t\t\t\t//遍历集合\n\t\t\t\tSystem.out.println(integer);\t\t\t//打印每一个元素\n\t\t\t}\n\n###17.07_集合框架(练习)\n* 使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符\n\t* aaaabbbcccddd\n\n\t\t\tScanner sc = new Scanner(System.in);\t\t\t//创建键盘录入对象\n\t\t\tSystem.out.println(\"请输入一行字符串:\");\n\t\t\tString line = sc.nextLine();\t\t\t\t\t//将键盘录入的字符串存储在line中\n\t\t\tchar[] arr = line.toCharArray();\t\t\t\t//将字符串转换成字符数组\n\t\t\tHashSet<Character> hs = new HashSet<>();\t\t//创建HashSet集合对象\n\t\t\t\n\t\t\tfor(char c : arr) {\t\t\t\t\t\t\t\t//遍历字符数组\n\t\t\t\ths.add(c);\t\t\t\t\t\t\t\t\t//将字符数组中的字符添加到集合中\n\t\t\t}\n\t\t\t\n\t\t\tfor (Character ch : hs) {\t\t\t\t\t\t//遍历集合\n\t\t\t\tSystem.out.println(ch);\n\t\t\t}\n###17.08_集合框架(练习)\n* 将集合中的重复元素去掉\n* \n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tArrayList<String> list = new ArrayList<>();\n\t\t\t\tlist.add(\"a\");\n\t\t\t\tlist.add(\"a\");\n\t\t\t\tlist.add(\"a\");\n\t\t\t\tlist.add(\"b\");\n\t\t\t\tlist.add(\"b\");\n\t\t\t\tlist.add(\"b\");\n\t\t\t\tlist.add(\"b\");\n\t\t\t\tlist.add(\"c\");\n\t\t\t\tlist.add(\"c\");\n\t\t\t\tlist.add(\"c\");\n\t\t\t\tlist.add(\"c\");\n\t\t\t\t\n\t\t\t\tSystem.out.println(list);\n\t\t\t\tSystem.out.println(\"去除重复后:\");\n\t\t\t\tgetSingle(list);\n\t\t\t\tSystem.out.println(list);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t * 将集合中的重复元素去掉\n\t\t\t * 1,void\n\t\t\t * 2,List<String> list\n\t\t\t */\n\t\t\t\n\t\t\tpublic static void getSingle(List<String> list) {\n\t\t\t\tLinkedHashSet<String> lhs = new LinkedHashSet<>();\n\t\t\t\tlhs.addAll(list);\t\t\t\t\t\t\t\t\t//将list集合中的所有元素添加到lhs\n\t\t\t\tlist.clear();\t\t\t\t\t\t\t\t\t\t//清空原集合\n\t\t\t\tlist.addAll(lhs);\t\t\t\t\t\t\t\t\t//将去除重复的元素添回到list中\n\t\t\t}\n\n###17.09_集合框架(TreeSet存储Integer类型的元素并遍历)\n* A:案例演示\n\t* TreeSet存储Integer类型的元素并遍历\n\n###17.10_集合框架(TreeSet存储自定义对象)\n* A:案例演示\n\t* 存储Person对象\n\n###17.11_集合框架(TreeSet保证元素唯一和自然排序的原理和图解)\n* A:画图演示\n\t* TreeSet保证元素唯一和自然排序的原理和图解\n\n###17.12_集合框架(TreeSet存储自定义对象并遍历练习1)\n* A:案例演示\n\t* TreeSet存储自定义对象并遍历练习1(按照姓名排序)\n\n###17.13_集合框架(TreeSet存储自定义对象并遍历练习2)\n* A:案例演示\n\t* TreeSet存储自定义对象并遍历练习2(按照姓名的长度排序)\n\n###17.14_集合框架(TreeSet保证元素唯一和比较器排序的原理及代码实现)\n* A:案例演示\n\t* TreeSet保证元素唯一和比较器排序的原理及代码实现\n\n###17.15_集合框架(TreeSet原理)\n* 1.特点\n\t* TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列\n* 2.使用方式\n\t* a.自然顺序(Comparable)\n\t\t* TreeSet类的add()方法中会把存入的对象提升为Comparable类型\n\t\t* 调用对象的compareTo()方法和集合中的对象比较\n\t\t* 根据compareTo()方法返回的结果进行存储\n\t* b.比较器顺序(Comparator)\n\t\t* 创建TreeSet的时候可以制定 一个Comparator\n\t\t* 如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序\n\t\t* add()方法内部会自动调用Comparator接口中compare()方法排序\n\t\t* 调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数\n\t* c.两种方式的区别\n\t\t* TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)\n\t\t* TreeSet如果传入Comparator, 就优先按照Comparator\n\n###17.16_集合框架(练习)\n* 在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复\n\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tArrayList<String> list = new ArrayList<>();\n\t\t\t\tlist.add(\"ccc\");\n\t\t\t\tlist.add(\"ccc\");\n\t\t\t\tlist.add(\"aaa\");\n\t\t\t\tlist.add(\"aaa\");\n\t\t\t\tlist.add(\"bbb\");\n\t\t\t\tlist.add(\"ddd\");\n\t\t\t\tlist.add(\"ddd\");\n\t\t\t\t\n\t\t\t\tsort(list);\n\t\t\t\tSystem.out.println(list);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t * 对集合中的元素排序,并保留重复\n\t\t\t * 1,void\n\t\t\t * 2,List<String> list\n\t\t\t */\n\t\t\tpublic static void sort(List<String> list) {\n\t\t\t\tTreeSet<String> ts = new TreeSet<>(new Comparator<String>() {\t\t//定义比较器(new Comparator(){}是Comparator的子类对象)\n\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String s1, String s2) {\t\t\t\t\t\t//重写compare方法\n\t\t\t\t\t\tint num = s1.compareTo(s2);\t\t\t\t\t\t\t\t\t//比较内容\n\t\t\t\t\t\treturn num == 0 ? 1 : num;\t\t\t\t\t\t\t\t\t//如果内容一样返回一个不为0的数字即可\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tts.addAll(list);\t\t\t\t\t\t\t\t\t\t\t\t\t//将list集合中的所有元素添加到ts中\n\t\t\t\tlist.clear();\t\t\t\t\t\t\t\t\t\t\t\t\t\t//清空list\n\t\t\t\tlist.addAll(ts);\t\t\t\t\t\t\t\t\t\t\t\t\t//将ts中排序并保留重复的结果在添加到list中\n\t\t\t}\n\n###17.17_集合框架(练习)\n* 从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillostt\n\n\t\tScanner sc = new Scanner(System.in);\t\t\t//创建键盘录入对象\n\t\tSystem.out.println(\"请输入一行字符串:\");\n\t\tString line = sc.nextLine();\t\t\t\t\t//将键盘录入的字符串存储在line中\n\t\tchar[] arr = line.toCharArray();\t\t\t\t//将字符串转换成字符数组\n\t\tTreeSet<Character> ts = new TreeSet<>(new Comparator<Character>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Character c1, Character c2) {\n\t\t\t\t//int num = c1.compareTo(c2);\n\t\t\t\tint num = c1 - c2;\t\t\t\t\t//自动拆箱\n\t\t\t\treturn num == 0 ? 1 : num;\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(char c : arr) {\n\t\t\tts.add(c);\n\t\t}\n\t\t\n\t\tfor(Character ch : ts) {\n\t\t\tSystem.out.print(ch);\n\t\t}\n###17.18_集合框架(练习)\n* 程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印.\n\t\t\tScanner sc = new Scanner(System.in);\t\t//创建键盘录入对象\n\t\t\tSystem.out.println(\"请输入:\");\n\t\t\tTreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {//将比较器传给TreeSet的构造方法\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Integer i1, Integer i2) {\n\t\t\t\t\t//int num = i2 - i1;\t\t\t\t\t//自动拆箱\n\t\t\t\t\tint num = i2.compareTo(i1);\n\t\t\t\t\treturn num == 0 ? 1 : num;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tString line = sc.nextLine();\t\t\t//将键盘录入的字符串存储在line中\n\t\t\t\tif(\"quit\".equals(line))\t\t\t\t\t//如果字符串常量和变量比较,常量放前面,这样不会出现空指针异常,变量里面可能存储null\n\t\t\t\t\tbreak;\n\t\t\t\ttry {\n\t\t\t\t\tint num = Integer.parseInt(line);\t\t//将数字字符串转换成数字\n\t\t\t\t\tts.add(num);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tSystem.out.println(\"您录入的数据有误,请输入一个整数\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor (Integer i : ts) {\t\t\t\t\t\t//遍历TreeSet集合\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n###17.19_集合框架(键盘录入学生信息按照总分排序后输出在控制台)\n* A:案例演示\n\t* 需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tSystem.out.println(\"请输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩)\");\n\t\t\tTreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Student s1, Student s2) {\n\t\t\t\t\tint num = s2.getSum() - s1.getSum();\t\t\t//根据学生的总成绩降序排列\n\t\t\t\t\treturn num == 0 ? 1 : num;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\twhile(ts.size() < 5) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\ttry {\n\t\t\t\t\tString[] arr = line.split(\",\");\n\t\t\t\t\tint chinese = Integer.parseInt(arr[1]);\t\t\t\t//转换语文成绩\n\t\t\t\t\tint math = Integer.parseInt(arr[2]);\t\t\t\t//转换数学成绩\n\t\t\t\t\tint english = Integer.parseInt(arr[3]);\t\t\t\t//转换英语成绩\n\t\t\t\t\tts.add(new Student(arr[0], chinese, math, english));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tSystem.out.println(\"录入格式有误,输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"排序后的学生成绩是:\");\n\t\t\tfor (Student s : ts) {\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\n###17.20_day17总结\n* 1.List\n\t* a.普通for循环, 使用get()逐个获取\n\t* b.调用iterator()方法得到Iterator, 使用hasNext()和next()方法\n\t* c.增强for循环, 只要可以使用Iterator的类都可以用\n\t* d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法\n* 2.Set\n\t* a.调用iterator()方法得到Iterator, 使用hasNext()和next()方法\n\t* b.增强for循环, 只要可以使用Iterator的类都可以用\n* 3.普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除 ","categories":[],"tags":[]}